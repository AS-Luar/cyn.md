# SPEECH UNDERSTANDING PRACTICE GUIDE

## EXERCISE GOAL
In this practice session, you'll build a speech understanding system that can recognize user intents, extract relevant information, and maintain conversational context. This will transform the raw text from speech recognition into structured data your voice assistant can act upon.

## STEP-BY-STEP INSTRUCTIONS

### Step 1: Set Up Your Project
Create a new file named `speech_understanding.py` in your project directory.

```python
# Line 1: Import necessary modules - (refer to teaching file section on Intent Recognition Techniques)
import re
import json
import time
import os
import random
```

**Checkpoint**: Verify all imports are working correctly.

### Step 2: Implement a Base Intent Recognizer
Create a class that can detect intents using a rule-based approach:

```python
# Line 2: Create IntentRecognizer class - (refer to teaching file section on Rule-based/Keyword Matching)
class IntentRecognizer:
    """A class for recognizing user intents from speech text."""
    
    def __init__(self):
        """Initialize the intent recognizer with predefined patterns."""
        # Initialize intent patterns
        self.intent_patterns = {
            "greeting": [
                r"(hello|hi|hey|greetings)( there| assistant| voice assistant)?",
                r"good (morning|afternoon|evening)"
            ],
            "farewell": [
                r"(goodbye|bye|see you( later)?)",
                r"(exit|quit|stop)( assistant| program)?"
            ],
            "weather_inquiry": [
                r"(what|how)('s| is) (the )?weather( like)?( in (?P<location>\w+))?",
                r"(weather|forecast)( in| for) (?P<location>[\w\s]+)",
                r"is it (going to|gonna) (rain|snow|be sunny)( in (?P<location>\w+))?"
            ],
            "time_inquiry": [
                r"what('s| is) (the )?time( now)?",
                r"(tell|give) me the (current |)time",
                r"what time is it"
            ],
            "date_inquiry": [
                r"what('s| is) (the )?date( today)?",
                r"what day is (it|today)",
                r"(tell|give) me the (current |)date"
            ],
            "device_control": [
                r"(turn|switch) (?P<action>on|off) (the )?(?P<device>[\w\s]+)( please)?",
                r"(dim|brighten) (the )?(?P<device>[\w\s]+)( please)?"
            ],
            "timer_set": [
                r"(set|start) a timer for (?P<duration>[\w\s]+)( please)?",
                r"timer for (?P<duration>[\w\s]+)( please)?"
            ],
            "general_question": [
                r"(who|what|where|when|why|how) (is|are|was|were|do|does) [\w\s]+",
                r"(can|could) you (tell|explain) [\w\s]+"
            ]
        }
    
    # Line 3: Implement intent detection method - (refer to teaching file section on Regular Expression Patterns)
    def detect_intent(self, text):
        """
        Detect the intent from the given text.
        
        Args:
            text: The text to analyze
            
        Returns:
            A tuple of (intent, entities) where entities is a dictionary
        """
        # Convert text to lowercase for case-insensitive matching
        text = text.lower()
        
        # Check each intent and its patterns
        for intent, patterns in self.intent_patterns.items():
            for pattern in patterns:
                match = re.search(pattern, text)
                if match:
                    # Extract entities from the match
                    entities = self._extract_entities(intent, match, text)
                    return intent, entities
        
        # No match found, return unknown intent
        return "unknown_intent", {}
    
    # Line 4: Implement entity extraction method - (refer to teaching file section on Entity Extraction and Slot Filling)
    def _extract_entities(self, intent, match, original_text):
        """
        Extract entities based on the matched pattern and intent.
        
        Args:
            intent: The detected intent
            match: The regex match object
            original_text: The original text input
            
        Returns:
            A dictionary of extracted entities
        """
        entities = {}
        
        # Extract named groups from the regex match
        for group_name in match.groupdict():
            entities[group_name] = match.group(group_name)
        
        # Additional processing for specific intents
        if intent == "weather_inquiry" and "location" not in entities:
            # Try to find location after "in" or "for"
            location_match = re.search(r"(in|for) (?P<location>[\w\s]+)$", original_text.lower())
            if location_match:
                entities["location"] = location_match.group("location").strip()
        
        elif intent == "timer_set" and "duration" in entities:
            # Convert duration text to seconds
            duration_text = entities["duration"]
            entities["seconds"] = self._parse_duration(duration_text)
            
        return entities
    
    # Line 5: Implement a helper function to parse time durations - (new helper function)
    def _parse_duration(self, duration_text):
        """
        Parse a duration string into seconds.
        
        Args:
            duration_text: Text like "5 minutes", "1 hour and 30 seconds", etc.
            
        Returns:
            Duration in seconds or None if parsing fails
        """
        total_seconds = 0
        
        # Try to extract hours
        hour_match = re.search(r"(\d+)(\s+)?(hour|hr)", duration_text)
        if hour_match:
            hours = int(hour_match.group(1))
            total_seconds += hours * 3600
        
        # Try to extract minutes
        minute_match = re.search(r"(\d+)(\s+)?(minute|min)", duration_text)
        if minute_match:
            minutes = int(minute_match.group(1))
            total_seconds += minutes * 60
        
        # Try to extract seconds
        second_match = re.search(r"(\d+)(\s+)?(second|sec)", duration_text)
        if second_match:
            seconds = int(second_match.group(1))
            total_seconds += seconds
        
        # If nothing was matched but there's a number, assume it's seconds
        if total_seconds == 0:
            number_match = re.search(r"(\d+)", duration_text)
            if number_match:
                total_seconds = int(number_match.group(1))
        
        return total_seconds if total_seconds > 0 else None
```

**Checkpoint**: Test the IntentRecognizer class with the following code:

```python
# Test the intent recognizer
recognizer = IntentRecognizer()
test_phrases = [
    "Hello there",
    "What's the weather like today",
    "What's the weather like in London",
    "What time is it",
    "Turn on the kitchen lights",
    "Set a timer for 5 minutes",
    "Who is the president"
]

for phrase in test_phrases:
    intent, entities = recognizer.detect_intent(phrase)
    print(f"Phrase: \"{phrase}\"")
    print(f"Intent: {intent}")
    print(f"Entities: {entities}")
    print()
```

### Step 3: Implement a Context Manager
Create a context manager to maintain conversation state:

```python
# Line 6: Create ContextManager class - (refer to teaching file section on Context Management)
class ContextManager:
    """A class for managing conversational context."""
    
    def __init__(self):
        """Initialize an empty context."""
        self.context = {}
        self.last_intent = None
        self.session_start = time.time()
        self.session_timeout = 300  # 5 minutes
    
    # Line 7: Implement context update method
    def update_context(self, intent, entities):
        """
        Update the context with new information.
        
        Args:
            intent: The detected intent
            entities: Dictionary of entities extracted from the utterance
        """
        # Reset if session has timed out
        if time.time() - self.session_start > self.session_timeout:
            self.reset_context()
        
        # Update session timestamp
        self.session_start = time.time()
        
        # Save the latest intent
        self.last_intent = intent
        
        # Update context with entities
        if entities:
            self.context.update(entities)
    
    # Line 8: Implement method to retrieve context values
    def get_context_value(self, key, default=None):
        """
        Get a value from the context.
        
        Args:
            key: The context key to retrieve
            default: Default value if key is not in context
            
        Returns:
            The value for the key or the default
        """
        return self.context.get(key, default)
    
    # Line 9: Implement context reset method
    def reset_context(self):
        """Reset the conversation context."""
        self.context = {}
        self.last_intent = None
        self.session_start = time.time()
    
    # Line 10: Implement method to get current state
    def get_state(self):
        """
        Get the current context state.
        
        Returns:
            Dictionary with context information
        """
        return {
            "context": self.context,
            "last_intent": self.last_intent,
            "session_age": time.time() - self.session_start
        }
```

**Checkpoint**: Test the ContextManager with a simulated conversation:

```python
# Test the context manager
context_manager = ContextManager()

# First interaction
intent1, entities1 = recognizer.detect_intent("What's the weather like in New York")
context_manager.update_context(intent1, entities1)
print("After first query:")
print(context_manager.get_state())
print()

# Second interaction 
intent2, entities2 = recognizer.detect_intent("How about tomorrow")
context_manager.update_context(intent2, entities2)
print("After second query:")
print(context_manager.get_state())
print(f"Location from context: {context_manager.get_context_value('location')}")
print()

# Reset and check
context_manager.reset_context()
print("After reset:")
print(context_manager.get_state())
```

### Step 4: Create a Dialog Manager
Implement a dialog manager to generate responses based on intents and context:

```python
# Line 11: Create DialogManager class - (refer to teaching file section on Dialog Management)
class DialogManager:
    """A class for managing dialog flow and responses."""
    
    def __init__(self):
        """Initialize the dialog manager."""
        self.intent_recognizer = IntentRecognizer()
        self.context_manager = ContextManager()
    
    # Line 12: Implement method to process user input
    def process_input(self, text):
        """
        Process user input and generate a response.
        
        Args:
            text: The user's input text
            
        Returns:
            A response string
        """
        # Detect intent and entities
        intent, entities = self.intent_recognizer.detect_intent(text)
        
        # Update context
        self.context_manager.update_context(intent, entities)
        
        # Generate response
        response = self.generate_response(intent, entities)
        
        return intent, entities, response
    
    # Line 13: Implement response generation method
    def generate_response(self, intent, entities):
        """
        Generate a response based on intent and entities.
        
        Args:
            intent: The detected intent
            entities: Dictionary of entities
            
        Returns:
            A response string
        """
        if intent == "greeting":
            greetings = [
                "Hello! How can I help you?",
                "Hi there! What can I do for you?",
                "Hey! How can I assist you today?",
                "Greetings! What do you need?"
            ]
            return random.choice(greetings)
        
        elif intent == "farewell":
            farewells = [
                "Goodbye! Have a great day!",
                "See you later!",
                "Bye for now!",
                "Until next time!"
            ]
            return random.choice(farewells)
        
        elif intent == "weather_inquiry":
            location = entities.get("location") or self.context_manager.get_context_value("location", "your location")
            # In a real application, you would call a weather API here
            weather_conditions = ["sunny", "cloudy", "rainy", "snowy", "windy", "clear"]
            temperatures = range(50, 85)
            condition = random.choice(weather_conditions)
            temperature = random.choice(temperatures)
            return f"The weather in {location} is currently {condition} with a temperature of {temperature}°F."
        
        elif intent == "time_inquiry":
            current_time = time.strftime("%I:%M %p")
            return f"The current time is {current_time}."
        
        elif intent == "date_inquiry":
            current_date = time.strftime("%A, %B %d, %Y")
            return f"Today is {current_date}."
        
        elif intent == "device_control":
            device = entities.get("device", "that device")
            action = entities.get("action", "unknown action")
            return f"I'll {action} {device} for you."
        
        elif intent == "timer_set":
            duration_str = entities.get("duration", "some time")
            seconds = entities.get("seconds")
            if seconds:
                minutes, seconds = divmod(seconds, 60)
                hours, minutes = divmod(minutes, 60)
                time_parts = []
                if hours:
                    time_parts.append(f"{hours} hour{'s' if hours > 1 else ''}")
                if minutes:
                    time_parts.append(f"{minutes} minute{'s' if minutes > 1 else ''}")
                if seconds:
                    time_parts.append(f"{seconds} second{'s' if seconds > 1 else ''}")
                    
                time_str = " and ".join(time_parts) if time_parts else duration_str
                return f"Timer set for {time_str}."
            else:
                return f"I couldn't understand the duration '{duration_str}'. Please try again with a clear time format like '5 minutes'."
        
        elif intent == "general_question":
            return "That's an interesting question. I don't have the answer right now."
        
        else:  # unknown_intent
            return "I'm not sure what you mean. Could you phrase that differently?"
```

**Checkpoint**: Test the DialogManager with some example queries:

```python
# Test the dialog manager
dialog_manager = DialogManager()
test_queries = [
    "Hello",
    "What's the weather like in Seattle",
    "What time is it",
    "Set a timer for 5 minutes",
    "Turn on the living room lights",
    "What's the weather like tomorrow",  # Should use Seattle from context
    "Goodbye"
]

print("Testing dialog manager with queries:")
for query in test_queries:
    print(f"\nUser: \"{query}\"")
    intent, entities, response = dialog_manager.process_input(query)
    print(f"Intent: {intent}")
    print(f"Entities: {entities}")
    print(f"Response: \"{response}\"")
```

### Step 5: Integrate with Speech Recognition
Create a main function that integrates with the speech recognition from the previous module:

```python
# Line 14: Create function to simulate speech recognition for testing
def simulate_speech_recognition():
    """
    Simulate speech recognition for testing without microphone.
    This function allows input from the terminal instead of using Vosk.
    """
    dialog_manager = DialogManager()
    
    print("\n=== Speech Understanding Test ===")
    print("Type your queries (or 'exit' to quit)")
    
    while True:
        # Get user input
        user_input = input("\nYou: ")
        if user_input.lower() == "exit":
            print("Exiting...")
            break
        
        # Process input
        intent, entities, response = dialog_manager.process_input(user_input)
        
        # Show debug info
        print(f"[DEBUG] Intent: {intent}")
        print(f"[DEBUG] Entities: {entities}")
        
        # Show response
        print(f"Assistant: {response}")

# Line 15: Create main function
def main():
    """Main entry point for the application."""
    try:
        # For testing without Vosk, use the simulation function
        simulate_speech_recognition()
        
        # In a real application, you would integrate with Vosk here
        # from a previous module's implementation
        
    except KeyboardInterrupt:
        print("\nProgram interrupted by user")
    except Exception as e:
        print(f"Error: {e}")

# Line 16: Standard boilerplate to call main function
if __name__ == "__main__":
    main()
```

**Checkpoint**: Run the complete script and test the understanding capabilities with different queries.

### Step 6: Optional Advanced Enhancement - Add Regex-free Intent Recognition
For more flexibility, let's add a fallback intent recognizer that doesn't rely on regexes:

```python
# Line 17: Create KeywordIntentRecognizer class - (a simpler alternative to regex)
class KeywordIntentRecognizer:
    """A class for recognizing intents based on keywords and phrases."""
    
    def __init__(self):
        """Initialize with intent keywords."""
        self.intent_keywords = {
            "greeting": ["hello", "hi", "hey", "greetings", "good morning", "good afternoon", "good evening"],
            "farewell": ["goodbye", "bye", "see you", "exit", "quit", "stop"],
            "weather_inquiry": ["weather", "forecast", "temperature", "sunny", "rainy", "cloudy"],
            "time_inquiry": ["time", "clock", "hour"],
            "date_inquiry": ["date", "day", "today", "calendar"],
            "device_control": ["turn on", "turn off", "switch on", "switch off", "dim", "brighten"],
            "timer_set": ["timer", "set timer", "alarm", "reminder"],
            "general_question": ["who", "what", "where", "when", "why", "how"]
        }
    
    def detect_intent(self, text):
        """
        Detect intent based on keyword matching.
        
        Args:
            text: The text to analyze
            
        Returns:
            The most likely intent
        """
        text = text.lower()
        
        # Count keyword matches for each intent
        matches = {intent: 0 for intent in self.intent_keywords}
        
        for intent, keywords in self.intent_keywords.items():
            for keyword in keywords:
                if keyword in text:
                    matches[intent] += 1
        
        # Find intent with most matches
        max_matches = 0
        best_intent = "unknown_intent"
        
        for intent, count in matches.items():
            if count > max_matches:
                max_matches = count
                best_intent = intent
        
        # Return unknown if no keywords matched
        if max_matches == 0:
            return "unknown_intent", {}
        
        # Extract basic entities (very simplified)
        entities = self._extract_basic_entities(text, best_intent)
        
        return best_intent, entities
    
    def _extract_basic_entities(self, text, intent):
        """
        Extract very basic entities without regexes.
        This is a simplified approach and won't work for all cases.
        
        Args:
            text: The input text
            intent: The detected intent
            
        Returns:
            A dictionary of extracted entities
        """
        entities = {}
        
        # Simple location extraction for weather queries
        if intent == "weather_inquiry" and " in " in text:
            location = text.split(" in ", 1)[1].strip()
            entities["location"] = location
        
        # Simple device extraction for device control
        if intent == "device_control":
            if "turn on" in text:
                device = text.split("turn on", 1)[1].strip()
                entities["action"] = "on"
                entities["device"] = device
            elif "turn off" in text:
                device = text.split("turn off", 1)[1].strip()
                entities["action"] = "off"
                entities["device"] = device
        
        return entities
```

To use this as a fallback, modify the DialogManager's process_input method:

```python
# Line 18: Update DialogManager to use both recognizers
class DialogManager:
    def __init__(self):
        # Add both recognizers
        self.regex_recognizer = IntentRecognizer()
        self.keyword_recognizer = KeywordIntentRecognizer()
        self.context_manager = ContextManager()
    
    def process_input(self, text):
        # Try regex first
        intent, entities = self.regex_recognizer.detect_intent(text)
        
        # If unknown, try keyword matching as fallback
        if intent == "unknown_intent":
            intent, entities = self.keyword_recognizer.detect_intent(text)
        
        # Update context
        self.context_manager.update_context(intent, entities)
        
        # Generate response
        response = self.generate_response(intent, entities)
        
        return intent, entities, response
```

**Checkpoint**: Test the improved dialog manager with more varied queries.

## PROGRESS CHECKPOINTS
- ✅ Created an intent recognizer using regex patterns
- ✅ Implemented entity extraction
- ✅ Created a context manager for maintaining conversation state
- ✅ Built a dialog manager for generating responses
- ✅ Integrated components into a complete system
- ✅ (Optional) Added a keyword-based fallback recognizer

## COMPLETION CRITERIA
You have successfully completed this exercise when:

1. Your system can correctly identify common intents from text input
2. It can extract relevant entities (parameters) from user utterances
3. It maintains context across multiple interactions
4. It generates appropriate responses based on intents and entities
5. You can have a simple conversation with the system

## TROUBLESHOOTING
- **Intent not recognized**: Check your regex patterns and make sure they're not too strict
- **Entities not extracted**: Verify your entity extraction code and regex capture groups
- **Context not maintained**: Make sure context is being properly updated and retrieved
- **Response generation errors**: Check for missing keys in your entity dictionaries
- **Integration issues**: Ensure all components are correctly connected
